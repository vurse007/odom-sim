<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lynx Path Planner</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&family=Syne:wght@400;700;800&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a0f;
    --surface: #111118;
    --surface2: #1a1a24;
    --border: #2a2a3a;
    --accent: #00d4ff;
    --accent2: #7c3aed;
    --accent3: #f59e0b;
    --text: #e8e8f0;
    --muted: #6b6b80;
    --danger: #ef4444;
    --success: #10b981;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  header {
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 20px;
    background: var(--surface);
    flex-shrink: 0;
  }

  header h1 {
    font-family: 'Syne', sans-serif;
    font-size: 18px;
    font-weight: 800;
    letter-spacing: -0.5px;
    color: var(--accent);
  }

  header span {
    font-size: 11px;
    color: var(--muted);
  }

  .main {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  /* ---- CANVAS AREA ---- */
  .canvas-wrap {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px;
    position: relative;
    background:
      radial-gradient(ellipse at 20% 20%, rgba(124,58,237,0.04) 0%, transparent 60%),
      radial-gradient(ellipse at 80% 80%, rgba(0,212,255,0.04) 0%, transparent 60%),
      var(--bg);
  }

  canvas {
    border: 1px solid var(--border);
    border-radius: 4px;
    cursor: crosshair;
    display: block;
  }

  canvas.dragging { cursor: grabbing; }
  canvas.hover-point { cursor: grab; }

  /* ---- SIDEBAR ---- */
  .sidebar {
    width: 300px;
    border-left: 1px solid var(--border);
    background: var(--surface);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    flex-shrink: 0;
  }

  .sidebar-section {
    border-bottom: 1px solid var(--border);
    padding: 14px;
  }

  .sidebar-section h2 {
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 10px;
  }

  .btn-row {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }

  button {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    padding: 6px 10px;
    border-radius: 3px;
    border: 1px solid var(--border);
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
    transition: all 0.15s;
  }
  button:hover { border-color: var(--accent); color: var(--accent); }
  button.danger:hover { border-color: var(--danger); color: var(--danger); }
  button.active { border-color: var(--accent); color: var(--accent); background: rgba(0,212,255,0.08); }

  .field-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  .field-row label {
    font-size: 10px;
    color: var(--muted);
    min-width: 110px;
  }
  .field-row input {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    padding: 4px 8px;
    border-radius: 2px;
    min-width: 0;
  }
  .field-row input:focus { outline: none; border-color: var(--accent); }

  /* point list */
  .point-list {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
  }
  .point-list::-webkit-scrollbar { width: 4px; }
  .point-list::-webkit-scrollbar-track { background: var(--bg); }
  .point-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .pt-item {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 8px 10px;
    margin-bottom: 6px;
    cursor: pointer;
    transition: all 0.1s;
    position: relative;
  }
  .pt-item:hover { border-color: var(--accent); }
  .pt-item.selected { border-color: var(--accent); background: rgba(0,212,255,0.06); }
  .pt-item .pt-label {
    font-size: 10px;
    color: var(--accent);
    font-weight: 600;
    margin-bottom: 4px;
  }
  .pt-item .pt-vals {
    font-size: 10px;
    color: var(--muted);
    line-height: 1.6;
  }
  .pt-item .pt-del {
    position: absolute;
    top: 6px; right: 8px;
    font-size: 10px;
    color: var(--muted);
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
  }
  .pt-item .pt-del:hover { color: var(--danger); }

  /* code output */
  .code-area {
    flex-shrink: 0;
    border-top: 1px solid var(--border);
  }
  .code-area h2 {
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    padding: 10px 14px 0;
  }
  .code-box {
    font-size: 10px;
    color: var(--accent);
    padding: 8px 14px 10px;
    max-height: 140px;
    overflow-y: auto;
    line-height: 1.7;
    white-space: pre;
  }
  .code-box::-webkit-scrollbar { width: 4px; }
  .code-box::-webkit-scrollbar-track { background: var(--bg); }
  .code-box::-webkit-scrollbar-thumb { background: var(--border); }

  .copy-btn {
    margin: 0 14px 10px;
    width: calc(100% - 28px);
  }

  /* edit panel */
  .edit-panel {
    padding: 10px 14px;
    background: var(--surface2);
    border-top: 1px solid var(--border);
    flex-shrink: 0;
  }
  .edit-panel h2 {
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 8px;
  }

  .mode-hint {
    font-size: 10px;
    color: var(--muted);
    padding: 6px 14px;
    border-top: 1px solid var(--border);
  }
</style>
</head>
<body>

<header>
  <h1>LYNX PATH PLANNER</h1>
  <span>Bezier Spline Editor — VEX Field (144" × 144")</span>
</header>

<div class="main">
  <div class="canvas-wrap">
    <canvas id="c"></canvas>
  </div>

  <div class="sidebar">
    <div class="sidebar-section">
      <h2>Controls</h2>
      <div class="btn-row">
        <button id="btnClear" class="danger">Clear All</button>
        <button id="btnUndo">Undo</button>
        <button id="btnReverse">Reverse</button>
        <button id="btnSmooth" class="active" title="Toggle tangent handles">Smooth</button>
      </div>
    </div>

    <div class="sidebar-section">
      <h2>Path Settings</h2>
      <div class="field-row">
        <label>Tangent Scale</label>
        <input type="number" id="tangentScale" value="0.4" min="0.05" max="1.5" step="0.05">
      </div>
      <div class="field-row">
        <label>Spacing (in)</label>
        <input type="number" id="spacingIn" value="0.5" min="0.1" max="4" step="0.1">
      </div>
      <div class="field-row">
        <label>Default Vel</label>
        <input type="number" id="defVel" value="100" min="0" max="127">
      </div>
    </div>

    <!-- selected point editor -->
    <div class="edit-panel" id="editPanel" style="display:none">
      <h2>Selected Point</h2>
      <div class="field-row">
        <label>X (in)</label>
        <input type="number" id="eX" step="0.5">
      </div>
      <div class="field-row">
        <label>Y (in)</label>
        <input type="number" id="eY" step="0.5">
      </div>
      <div class="field-row">
        <label>Heading (°)</label>
        <input type="number" id="eH" step="1" min="0" max="359">
      </div>
      <div class="field-row">
        <label>Velocity</label>
        <input type="number" id="eV" step="1" min="0" max="127">
      </div>
    </div>

    <div class="point-list" id="pointList"></div>

    <div class="code-area">
      <h2>C++ Output</h2>
      <div class="code-box" id="codeBox"></div>
      <button class="copy-btn" id="btnCopy">Copy to Clipboard</button>
    </div>

    <div class="mode-hint" id="modeHint">Click on field to add waypoints</div>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// VEX field is 144" × 144"
const FIELD_IN = 144;

// State
let points = []; // [{x, y, heading, velocity}]
let selectedIdx = -1;
let dragIdx = -1;
let dragOffX = 0, dragOffY = 0;
let smoothMode = true;
let history = [];

// Canvas sizing
function resizeCanvas() {
  const wrap = canvas.parentElement;
  const size = Math.min(wrap.clientWidth - 32, wrap.clientHeight - 32);
  canvas.width  = size;
  canvas.height = size;
  render();
}

// Coordinate transforms
function toCanvas(ix, iy) {
  const s = canvas.width / FIELD_IN;
  return { cx: ix * s, cy: (FIELD_IN - iy) * s };
}

function toField(cx, cy) {
  const s = FIELD_IN / canvas.width;
  return { ix: cx * s, iy: FIELD_IN - cy * s };
}

// ---- Bezier math ----
function cubicBezier(p0, c1, c2, p3, t) {
  const mt = 1 - t;
  return {
    x: mt*mt*mt*p0.x + 3*mt*mt*t*c1.x + 3*mt*t*t*c2.x + t*t*t*p3.x,
    y: mt*mt*mt*p0.y + 3*mt*mt*t*c1.y + 3*mt*t*t*c2.y + t*t*t*p3.y
  };
}

function headingToTangent(hdeg) {
  // IMU heading to dx,dy: 0=N(+Y), 90=E(+X), CW+
  const rad = hdeg * Math.PI / 180;
  return { dx: Math.sin(rad), dy: Math.cos(rad) };
}

function tangentToHeading(dx, dy) {
  // atan2 in IMU frame
  let deg = Math.atan2(dx, dy) * 180 / Math.PI;
  return ((deg % 360) + 360) % 360;
}

function getSegmentPoints(p0, p1, tangentScale) {
  const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
  const handle = dist * tangentScale;
  const t0 = headingToTangent(p0.heading);
  const t1 = headingToTangent(p1.heading);
  const c1 = { x: p0.x + handle * t0.dx, y: p0.y + handle * t0.dy };
  const c2 = { x: p1.x - handle * t1.dx, y: p1.y - handle * t1.dy };
  return { c1, c2 };
}

// ---- Render ----
function render() {
  const W = canvas.width;
  ctx.clearRect(0, 0, W, W);

  // Field background
  ctx.fillStyle = '#0d1117';
  ctx.fillRect(0, 0, W, W);

  // Grid (every 24 inches = 2 ft)
  ctx.strokeStyle = '#1e2433';
  ctx.lineWidth = 1;
  for (let i = 0; i <= FIELD_IN; i += 24) {
    const { cx } = toCanvas(i, 0);
    const { cy } = toCanvas(0, i);
    ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, W); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(W, cy); ctx.stroke();
  }

  // Field border
  ctx.strokeStyle = '#3a3a55';
  ctx.lineWidth = 2;
  ctx.strokeRect(1, 1, W-2, W-2);

  // Tick labels
  ctx.fillStyle = '#3a3a55';
  ctx.font = `${Math.max(8, W/80)}px JetBrains Mono`;
  ctx.textAlign = 'center';
  for (let i = 0; i <= FIELD_IN; i += 24) {
    const { cx } = toCanvas(i, 0);
    const { cy } = toCanvas(0, i);
    ctx.fillText(i + '"', cx, W - 4);
    if (i > 0) ctx.fillText(i + '"', 20, cy + 4);
  }

  // Draw Bezier path
  const ts = parseFloat(document.getElementById('tangentScale').value) || 0.4;

  if (points.length >= 2) {
    // Filled path for reference
    ctx.beginPath();
    const s0 = toCanvas(points[0].x, points[0].y);
    ctx.moveTo(s0.cx, s0.cy);

    for (let i = 0; i < points.length - 1; i++) {
      const { c1, c2 } = getSegmentPoints(points[i], points[i+1], ts);
      const cc1 = toCanvas(c1.x, c1.y);
      const cc2 = toCanvas(c2.x, c2.y);
      const ep  = toCanvas(points[i+1].x, points[i+1].y);
      ctx.bezierCurveTo(cc1.cx, cc1.cy, cc2.cx, cc2.cy, ep.cx, ep.cy);
    }

    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.stroke();

    // Draw velocity heatmap dots along curve
    for (let i = 0; i < points.length - 1; i++) {
      const { c1, c2 } = getSegmentPoints(points[i], points[i+1], ts);
      const steps = 30;
      for (let s = 0; s <= steps; s++) {
        const t = s / steps;
        const pt = cubicBezier(points[i], c1, c2, points[i+1], t);
        const v = points[i].velocity + t * (points[i+1].velocity - points[i].velocity);
        const c = toCanvas(pt.x, pt.y);
        const r = v / 127;
        ctx.beginPath();
        ctx.arc(c.cx, c.cy, 2, 0, Math.PI*2);
        ctx.fillStyle = `hsl(${120 + (1-r)*120}, 80%, 55%)`;
        ctx.fill();
      }
    }

    // Heading arrows along path
    if (smoothMode) {
      for (let i = 0; i < points.length - 1; i++) {
        const { c1, c2 } = getSegmentPoints(points[i], points[i+1], ts);
        const cc1 = toCanvas(c1.x, c1.y);
        const cc2 = toCanvas(c2.x, c2.y);
        const sp  = toCanvas(points[i].x, points[i].y);
        const ep  = toCanvas(points[i+1].x, points[i+1].y);

        // Draw tangent handles
        ctx.setLineDash([3, 4]);
        ctx.strokeStyle = 'rgba(124,58,237,0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(sp.cx, sp.cy); ctx.lineTo(cc1.cx, cc1.cy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ep.cx, ep.cy); ctx.lineTo(cc2.cx, cc2.cy); ctx.stroke();
        ctx.setLineDash([]);

        // Control point dots
        ctx.fillStyle = 'rgba(124,58,237,0.7)';
        ctx.beginPath(); ctx.arc(cc1.cx, cc1.cy, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cc2.cx, cc2.cy, 3, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  // Draw waypoints
  const scale = canvas.width / FIELD_IN;
  points.forEach((pt, i) => {
    const { cx, cy } = toCanvas(pt.x, pt.y);
    const isSelected = i === selectedIdx;
    const isFirst = i === 0;
    const isLast  = i === points.length - 1;

    // Heading arrow
    const t = headingToTangent(pt.heading);
    const arrowLen = 12;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    const ax = cx + t.dx * arrowLen;
    const ay = cy - t.dy * arrowLen; // flip Y for canvas
    ctx.lineTo(ax, ay);
    ctx.strokeStyle = isSelected ? '#f59e0b' : 'rgba(0,212,255,0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Arrowhead
    const angle = Math.atan2(-(ay - cy), ax - cx);
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - 6*Math.cos(angle-0.4), ay - 6*Math.sin(angle-0.4));
    ctx.lineTo(ax - 6*Math.cos(angle+0.4), ay - 6*Math.sin(angle+0.4));
    ctx.closePath();
    ctx.fillStyle = isSelected ? '#f59e0b' : 'rgba(0,212,255,0.6)';
    ctx.fill();

    // Point circle
    const r = 7;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.fillStyle = isFirst ? '#10b981' : isLast ? '#ef4444' : isSelected ? '#f59e0b' : '#00d4ff';
    ctx.fill();
    ctx.strokeStyle = isSelected ? 'white' : 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Index label
    ctx.fillStyle = '#0a0a0f';
    ctx.font = `bold ${Math.max(9, scale/10)}px JetBrains Mono`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(i, cx, cy);
  });

  ctx.textBaseline = 'alphabetic';
}

// ---- Interaction ----
function getHitPoint(cx, cy) {
  const hitR = 10;
  for (let i = 0; i < points.length; i++) {
    const p = toCanvas(points[i].x, points[i].y);
    if (Math.hypot(cx - p.cx, cy - p.cy) < hitR) return i;
  }
  return -1;
}

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  const hit = getHitPoint(cx, cy);

  if (hit >= 0) {
    pushHistory();
    dragIdx = hit;
    selectedIdx = hit;
    canvas.classList.add('dragging');
  } else {
    pushHistory();
    const { ix, iy } = toField(cx, cy);
    const defVel = parseFloat(document.getElementById('defVel').value) || 100;

    // Auto-heading toward next or from prev
    let heading = 0;
    if (points.length > 0) {
      const prev = points[points.length - 1];
      const dx = ix - prev.x;
      const dy = iy - prev.y;
      heading = tangentToHeading(dx, dy);
    }

    points.push({ x: +ix.toFixed(2), y: +iy.toFixed(2), heading, velocity: defVel });
    selectedIdx = points.length - 1;
  }

  updateUI();
  render();
});

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;

  if (dragIdx >= 0) {
    const { ix, iy } = toField(cx, cy);
    points[dragIdx].x = +ix.toFixed(2);
    points[dragIdx].y = +iy.toFixed(2);
    updateUI();
    render();
  } else {
    const hit = getHitPoint(cx, cy);
    canvas.className = hit >= 0 ? 'hover-point' : '';
  }
});

canvas.addEventListener('mouseup', () => {
  dragIdx = -1;
  canvas.classList.remove('dragging');
});

canvas.addEventListener('dblclick', e => {
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  const hit = getHitPoint(cx, cy);
  if (hit >= 0) {
    pushHistory();
    points.splice(hit, 1);
    selectedIdx = -1;
    updateUI();
    render();
  }
});

// ---- Edit panel ----
function setupEditListeners() {
  ['eX','eY','eH','eV'].forEach(id => {
    document.getElementById(id).addEventListener('input', () => {
      if (selectedIdx < 0) return;
      const x = parseFloat(document.getElementById('eX').value);
      const y = parseFloat(document.getElementById('eY').value);
      const h = parseFloat(document.getElementById('eH').value);
      const v = parseFloat(document.getElementById('eV').value);
      if (!isNaN(x)) points[selectedIdx].x = x;
      if (!isNaN(y)) points[selectedIdx].y = y;
      if (!isNaN(h)) points[selectedIdx].heading = ((h % 360) + 360) % 360;
      if (!isNaN(v)) points[selectedIdx].velocity = Math.min(127, Math.max(0, v));
      updateUI();
      render();
    });
  });
}

// ---- UI update ----
function updateUI() {
  const list = document.getElementById('pointList');
  list.innerHTML = '';
  points.forEach((pt, i) => {
    const div = document.createElement('div');
    div.className = 'pt-item' + (i === selectedIdx ? ' selected' : '');
    div.innerHTML = `
      <div class="pt-label">${i === 0 ? '⬤ START' : i === points.length-1 ? '⬤ END' : `PT ${i}`}</div>
      <div class="pt-vals">x: ${pt.x.toFixed(1)}"  y: ${pt.y.toFixed(1)}"
hdg: ${pt.heading.toFixed(0)}°  vel: ${pt.velocity}</div>
      <button class="pt-del" data-i="${i}">✕</button>`;
    div.addEventListener('click', e => {
      if (e.target.classList.contains('pt-del')) {
        pushHistory();
        points.splice(parseInt(e.target.dataset.i), 1);
        selectedIdx = -1;
      } else {
        selectedIdx = i;
      }
      updateUI(); render();
    });
    list.appendChild(div);
  });

  // Edit panel
  const ep = document.getElementById('editPanel');
  if (selectedIdx >= 0 && points[selectedIdx]) {
    ep.style.display = 'block';
    const pt = points[selectedIdx];
    document.getElementById('eX').value = pt.x.toFixed(2);
    document.getElementById('eY').value = pt.y.toFixed(2);
    document.getElementById('eH').value = pt.heading.toFixed(0);
    document.getElementById('eV').value = pt.velocity;
  } else {
    ep.style.display = 'none';
  }

  // Code output
  updateCode();

  // Hint
  document.getElementById('modeHint').textContent =
    points.length === 0 ? 'Click on field to add waypoints' :
    points.length === 1 ? 'Add more points to build a path' :
    `${points.length} waypoints — double-click to delete`;
}

function updateCode() {
  const box = document.getElementById('codeBox');
  if (points.length < 2) {
    box.textContent = '// Add at least 2 points...';
    return;
  }

  const ts = parseFloat(document.getElementById('tangentScale').value) || 0.4;
  const sp = parseFloat(document.getElementById('spacingIn').value) || 0.5;

  let lines = [];
  lines.push('std::vector<lynx::BezierPath::ControlPoint> ctrl = {');
  points.forEach((pt, i) => {
    const comma = i < points.length - 1 ? ',' : '';
    lines.push(`    {${pt.x.toFixed(2)}, ${pt.y.toFixed(2)}, ${pt.heading.toFixed(1)}, ${pt.velocity}}${comma}`);
  });
  lines.push('};');
  lines.push('');
  lines.push(`auto path = lynx::BezierPath::from_control_points(`);
  lines.push(`    ctrl, ${ts}, ${sp});`);
  lines.push('');
  lines.push('chassis.purePursuit(path, 5000, params);');

  box.textContent = lines.join('\n');
}

// ---- Buttons ----
document.getElementById('btnClear').addEventListener('click', () => {
  pushHistory();
  points = [];
  selectedIdx = -1;
  updateUI(); render();
});

document.getElementById('btnUndo').addEventListener('click', () => {
  if (history.length > 0) {
    points = history.pop();
    selectedIdx = -1;
    updateUI(); render();
  }
});

document.getElementById('btnReverse').addEventListener('click', () => {
  if (points.length < 2) return;
  pushHistory();
  points.reverse();
  points = points.map(p => ({...p, heading: ((p.heading + 180) % 360)}));
  selectedIdx = -1;
  updateUI(); render();
});

document.getElementById('btnSmooth').addEventListener('click', () => {
  smoothMode = !smoothMode;
  document.getElementById('btnSmooth').classList.toggle('active', smoothMode);
  render();
});

document.getElementById('btnCopy').addEventListener('click', () => {
  navigator.clipboard.writeText(document.getElementById('codeBox').textContent);
  const btn = document.getElementById('btnCopy');
  btn.textContent = 'Copied!';
  setTimeout(() => btn.textContent = 'Copy to Clipboard', 1500);
});

['tangentScale','spacingIn','defVel'].forEach(id => {
  document.getElementById(id).addEventListener('input', () => { updateUI(); render(); });
});

function pushHistory() {
  history.push(JSON.parse(JSON.stringify(points)));
  if (history.length > 30) history.shift();
}

// ---- Init ----
setupEditListeners();
resizeCanvas();
window.addEventListener('resize', resizeCanvas);
updateUI();
</script>
</body>
</html>
