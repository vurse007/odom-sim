<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lynx Path Planner</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&family=Syne:wght@400;700;800&display=swap');
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a0f; --surface: #111118; --surface2: #1a1a24;
    --border: #2a2a3a; --accent: #00d4ff; --accent2: #7c3aed;
    --text: #e8e8f0; --muted: #6b6b80; --danger: #ef4444; --success: #10b981;
  }

  body {
    background: var(--bg); color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    height: 100vh; overflow: hidden;
    display: flex; flex-direction: column;
  }

  header {
    padding: 10px 20px; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 20px;
    background: var(--surface); flex-shrink: 0;
  }
  header h1 {
    font-family: 'Syne', sans-serif; font-size: 18px;
    font-weight: 800; letter-spacing: -0.5px; color: var(--accent);
  }
  header span { font-size: 11px; color: var(--muted); }

  .main { display: flex; flex: 1; overflow: hidden; min-height: 0; }

  /* ---- CANVAS ---- */
  .canvas-wrap {
    flex: 1; position: relative; overflow: hidden;
    background: radial-gradient(ellipse at 20% 20%, rgba(124,58,237,0.04) 0%, transparent 60%),
                radial-gradient(ellipse at 80% 80%, rgba(0,212,255,0.04) 0%, transparent 60%),
                var(--bg);
  }
  canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
  canvas.panning  { cursor: grab; }
  canvas.dragging { cursor: grabbing; }
  canvas.hover-pt { cursor: grab; }

  .coords-badge {
    position: absolute; bottom: 12px; left: 12px;
    font-size: 10px; color: var(--muted);
    background: rgba(10,10,15,0.85); padding: 4px 8px;
    border-radius: 3px; border: 1px solid var(--border); pointer-events: none;
  }
  .zoom-btns {
    position: absolute; bottom: 12px; right: 12px;
    display: flex; flex-direction: column; gap: 4px;
  }
  .zoom-btns button { width: 28px; height: 28px; font-size: 14px; padding: 0; }

  /* ---- SIDEBAR ---- */
  /*
    KEY LAYOUT:
    .sidebar is a flex column with fixed height (100%)
    .sidebar-scroll gets flex:1 + min-height:0 → actually scrolls
    .sidebar-bottom is flex-shrink:0 → always pinned at bottom
  */
  .sidebar {
    width: 300px; flex-shrink: 0;
    border-left: 1px solid var(--border);
    background: var(--surface);
    display: flex; flex-direction: column;
    height: 100%; overflow: hidden;
  }

  .sidebar-scroll {
    flex: 1; min-height: 0;   /* these two together enable inner scroll */
    overflow-y: auto; overflow-x: hidden;
  }
  .sidebar-scroll::-webkit-scrollbar { width: 4px; }
  .sidebar-scroll::-webkit-scrollbar-track { background: var(--bg); }
  .sidebar-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .sidebar-bottom {
    flex-shrink: 0;
    border-top: 2px solid var(--border);
    background: var(--surface);
  }

  /* panels inside scroll */
  .panel {
    border-bottom: 1px solid var(--border);
    padding: 9px 14px;
  }
  .panel h2 {
    font-size: 10px; font-weight: 600;
    letter-spacing: 2px; text-transform: uppercase;
    color: var(--muted); margin-bottom: 8px;
  }
  .panel.origin { background: rgba(0,212,255,0.04); border-left: 2px solid var(--accent); }
  .panel.origin h2 { color: var(--accent); }

  .btn-row { display: flex; gap: 6px; flex-wrap: wrap; }

  button {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px; padding: 6px 10px;
    border-radius: 3px; border: 1px solid var(--border);
    background: var(--surface2); color: var(--text);
    cursor: pointer; transition: all 0.15s;
  }
  button:hover { border-color: var(--accent); color: var(--accent); }
  button.danger:hover { border-color: var(--danger); color: var(--danger); }
  button.active { border-color: var(--accent); color: var(--accent); background: rgba(0,212,255,0.08); }

  .field-row {
    display: flex; align-items: center; gap: 8px; margin-bottom: 7px;
  }
  .field-row:last-child { margin-bottom: 0; }
  .field-row label { font-size: 10px; color: var(--muted); min-width: 110px; }
  .field-row input {
    flex: 1; background: var(--bg); border: 1px solid var(--border);
    color: var(--text); font-family: 'JetBrains Mono', monospace;
    font-size: 11px; padding: 4px 8px; border-radius: 2px; min-width: 0;
  }
  .field-row input:focus { outline: none; border-color: var(--accent); }

  .origin-row { display: flex; gap: 6px; align-items: center; margin-bottom: 5px; }
  .origin-row:last-child { margin-bottom: 0; }
  .origin-row label { font-size: 10px; color: var(--muted); width: 14px; }
  .origin-row input {
    flex: 1; background: var(--bg); border: 1px solid var(--accent);
    color: var(--accent); font-family: 'JetBrains Mono', monospace;
    font-size: 11px; padding: 4px 8px; border-radius: 2px;
  }
  .origin-row input:focus { outline: none; }

  /* point list — no scroll here, parent scrolls */
  .point-list { padding: 8px; }

  .pt-item {
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 3px; padding: 7px 10px; margin-bottom: 5px;
    cursor: pointer; transition: border-color 0.1s; position: relative;
  }
  .pt-item:hover { border-color: var(--accent); }
  .pt-item.selected { border-color: var(--accent); background: rgba(0,212,255,0.06); }
  .pt-item .pt-label { font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 2px; }
  .pt-item .pt-vals { font-size: 10px; color: var(--muted); line-height: 1.5; }
  .pt-item .pt-del {
    position: absolute; top: 6px; right: 8px;
    font-size: 10px; color: var(--muted);
    background: none; border: none; padding: 0; cursor: pointer;
  }
  .pt-item .pt-del:hover { color: var(--danger); }

  /* pinned bottom */
  .code-area h2 {
    font-size: 10px; font-weight: 600;
    letter-spacing: 2px; text-transform: uppercase;
    color: var(--muted); padding: 8px 14px 0;
  }
  .code-box {
    font-size: 10px; color: var(--accent);
    padding: 6px 14px; max-height: 90px; overflow-y: auto;
    line-height: 1.6; white-space: pre;
  }
  .code-box::-webkit-scrollbar { width: 4px; }
  .code-box::-webkit-scrollbar-track { background: var(--bg); }
  .code-box::-webkit-scrollbar-thumb { background: var(--border); }
  .copy-btn { margin: 0 14px 8px; width: calc(100% - 28px); }
  .mode-hint {
    font-size: 10px; color: var(--muted);
    padding: 5px 14px; border-top: 1px solid var(--border);
  }
</style>
</head>
<body>

<header>
  <h1>LYNX PATH PLANNER</h1>
  <span>Click=add point · Drag=move · Drag handle=rotate · Scroll=zoom · Space+drag=pan · Dbl-click=delete</span>
</header>

<div class="main">
  <div class="canvas-wrap">
    <canvas id="c"></canvas>
    <div class="coords-badge" id="coordsBadge">x: 0.0  y: 0.0</div>
    <div class="zoom-btns">
      <button id="btnZoomIn">+</button>
      <button id="btnZoomOut">−</button>
      <button id="btnZoomReset" style="font-size:9px">⌂</button>
    </div>
  </div>

  <div class="sidebar">

    <!-- scrollable area: everything scrolls together -->
    <div class="sidebar-scroll">

      <div class="panel origin">
        <h2>Robot Start Position</h2>
        <div class="origin-row"><label>X</label><input type="number" id="originX" value="0" step="0.5"></div>
        <div class="origin-row"><label>Y</label><input type="number" id="originY" value="0" step="0.5"></div>
      </div>

      <div class="panel">
        <h2>Controls</h2>
        <div class="btn-row">
          <button id="btnClear" class="danger">Clear</button>
          <button id="btnUndo">Undo</button>
          <button id="btnReverse">Reverse</button>
          <button id="btnSmooth" class="active">Handles</button>
        </div>
      </div>

      <div class="panel">
        <h2>Path Settings</h2>
        <div class="field-row"><label>Tangent Scale</label><input type="number" id="tangentScale" value="0.4" min="0.05" max="1.5" step="0.05"></div>
        <div class="field-row"><label>Spacing (in)</label><input type="number" id="spacingIn" value="0.5" min="0.1" max="4" step="0.1"></div>
        <div class="field-row"><label>Default Vel</label><input type="number" id="defVel" value="100" min="0" max="127"></div>
      </div>

      <div class="panel" id="editPanel" style="display:none">
        <h2>Selected Point</h2>
        <div class="field-row"><label>X (in)</label><input type="number" id="eX" step="0.5"></div>
        <div class="field-row"><label>Y (in)</label><input type="number" id="eY" step="0.5"></div>
        <div class="field-row"><label>Heading (°)</label><input type="number" id="eH" step="1" min="0" max="359"></div>
        <div class="field-row"><label>Velocity</label><input type="number" id="eV" step="1" min="0" max="127"></div>
      </div>

      <div class="point-list" id="pointList"></div>

    </div><!-- end sidebar-scroll -->

    <!-- always visible at bottom -->
    <div class="sidebar-bottom">
      <div class="code-area">
        <h2>C++ Output</h2>
        <div class="code-box" id="codeBox">// Add at least 2 points...</div>
        <button class="copy-btn" id="btnCopy">Copy to Clipboard</button>
      </div>
      <div class="mode-hint" id="modeHint">Click on canvas to place first waypoint</div>
    </div>

  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');

// View state
let viewOriginX = 0, viewOriginY = 0;
let zoom = 4;

// App state
let points      = [];
let selectedIdx = -1;
let dragIdx     = -1;
let dragHandle  = null;
let smoothMode  = true;
let history     = [];

// Pan state
let isPanning = false, panStartX = 0, panStartY = 0, panOriginX = 0, panOriginY = 0;
let spaceDown = false;

// ---- Canvas resize ----
function resizeCanvas() {
  const wrap = canvas.parentElement;
  canvas.width  = wrap.clientWidth;
  canvas.height = wrap.clientHeight;
  if (viewOriginX === 0 && viewOriginY === 0) {
    viewOriginX = canvas.width  / 2;
    viewOriginY = canvas.height / 2;
  }
  render();
}

// ---- Coordinate transforms ----
function toCanvas(ix, iy) {
  return { cx: viewOriginX + ix * zoom, cy: viewOriginY - iy * zoom };
}
function toField(cx, cy) {
  return { ix: (cx - viewOriginX) / zoom, iy: -(cy - viewOriginY) / zoom };
}
function getOriginOffset() {
  return {
    ox: parseFloat(document.getElementById('originX').value) || 0,
    oy: parseFloat(document.getElementById('originY').value) || 0
  };
}
function toCodeCoords(pt) {
  if (points.length === 0) return { x: 0, y: 0 };
  const { ox, oy } = getOriginOffset();
  const a = points[0];
  return { x: +(pt.x - a.x + ox).toFixed(2), y: +(pt.y - a.y + oy).toFixed(2) };
}

// ---- Bezier math ----
function cubicBezier(p0, c1, c2, p3, t) {
  const mt = 1 - t;
  return {
    x: mt*mt*mt*p0.x + 3*mt*mt*t*c1.x + 3*mt*t*t*c2.x + t*t*t*p3.x,
    y: mt*mt*mt*p0.y + 3*mt*mt*t*c1.y + 3*mt*t*t*c2.y + t*t*t*p3.y
  };
}
function headingToTangent(h) {
  const r = h * Math.PI / 180;
  return { dx: Math.sin(r), dy: Math.cos(r) };
}
function tangentToHeading(dx, dy) {
  return (((Math.atan2(dx, dy) * 180 / Math.PI) % 360) + 360) % 360;
}
function getSegmentHandles(p0, p1, ts) {
  const handle = Math.hypot(p1.x - p0.x, p1.y - p0.y) * ts;
  const t0 = headingToTangent(p0.heading), t1 = headingToTangent(p1.heading);
  return {
    c1: { x: p0.x + handle * t0.dx, y: p0.y + handle * t0.dy },
    c2: { x: p1.x - handle * t1.dx, y: p1.y - handle * t1.dy }
  };
}

// ---- Render ----
function render() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#0d1117';
  ctx.fillRect(0, 0, W, H);

  // Grid
  const minor = 6, major = 24;
  const lx = toField(0,0).ix, rx = toField(W,0).ix;
  const ty = toField(0,0).iy, by = toField(0,H).iy;
  const sx = Math.floor(lx/minor)*minor, ex = Math.ceil(rx/minor)*minor;
  const sy = Math.floor(by/minor)*minor, ey = Math.ceil(ty/minor)*minor;

  ctx.lineWidth = 1;
  ctx.strokeStyle = '#161820';
  for (let ix = sx; ix <= ex; ix += minor) {
    if (ix % major === 0) continue;
    const {cx} = toCanvas(ix,0);
    ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,H); ctx.stroke();
  }
  for (let iy = sy; iy <= ey; iy += minor) {
    if (iy % major === 0) continue;
    const {cy} = toCanvas(0,iy);
    ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(W,cy); ctx.stroke();
  }
  ctx.strokeStyle = '#1e2433';
  for (let ix = sx; ix <= ex; ix += major) {
    const {cx} = toCanvas(ix,0);
    ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,H); ctx.stroke();
  }
  for (let iy = sy; iy <= ey; iy += major) {
    const {cy} = toCanvas(0,iy);
    ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(W,cy); ctx.stroke();
  }

  // Axes
  const o = toCanvas(0,0);
  ctx.strokeStyle = '#2a3a2a'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(0,o.cy); ctx.lineTo(W,o.cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(o.cx,0); ctx.lineTo(o.cx,H); ctx.stroke();

  // Labels
  ctx.fillStyle = '#2a3050';
  ctx.font = `${Math.max(9,Math.min(12,zoom*1.2))}px JetBrains Mono`;
  ctx.textAlign = 'center';
  for (let ix = sx; ix <= ex; ix += major) {
    const {cx} = toCanvas(ix,0);
    ctx.fillText(ix+'"', cx, Math.min(H-4, Math.max(14, o.cy+14)));
  }
  ctx.textAlign = 'right';
  for (let iy = sy; iy <= ey; iy += major) {
    if (iy === 0) continue;
    const {cy} = toCanvas(0,iy);
    ctx.fillText(iy+'"', Math.min(W-4,Math.max(24,o.cx-4)), cy+4);
  }
  ctx.fillStyle = '#3a3a55'; ctx.textAlign = 'left';
  ctx.fillText('(0,0)', o.cx+4, o.cy-4);

  const ts = parseFloat(document.getElementById('tangentScale').value) || 0.4;

  // Path
  if (points.length >= 2) {
    ctx.beginPath();
    const s0 = toCanvas(points[0].x, points[0].y);
    ctx.moveTo(s0.cx, s0.cy);
    for (let i = 0; i < points.length - 1; i++) {
      const {c1,c2} = getSegmentHandles(points[i], points[i+1], ts);
      const cc1 = toCanvas(c1.x,c1.y), cc2 = toCanvas(c2.x,c2.y);
      const ep  = toCanvas(points[i+1].x, points[i+1].y);
      ctx.bezierCurveTo(cc1.cx,cc1.cy, cc2.cx,cc2.cy, ep.cx,ep.cy);
    }
    ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 2; ctx.setLineDash([]); ctx.stroke();

    // Velocity heatmap
    for (let i = 0; i < points.length - 1; i++) {
      const {c1,c2} = getSegmentHandles(points[i], points[i+1], ts);
      for (let s = 0; s <= 30; s++) {
        const t = s/30;
        const pt = cubicBezier(points[i], c1, c2, points[i+1], t);
        const v  = points[i].velocity + t*(points[i+1].velocity - points[i].velocity);
        const c  = toCanvas(pt.x, pt.y);
        ctx.beginPath();
        ctx.arc(c.cx, c.cy, Math.max(1.5, zoom*0.12), 0, Math.PI*2);
        ctx.fillStyle = `hsl(${120+(1-v/127)*120},80%,55%)`;
        ctx.fill();
      }
    }

    // Handles
    if (smoothMode) {
      for (let i = 0; i < points.length - 1; i++) {
        const {c1,c2} = getSegmentHandles(points[i], points[i+1], ts);
        const cc1=toCanvas(c1.x,c1.y), cc2=toCanvas(c2.x,c2.y);
        const sp=toCanvas(points[i].x,points[i].y), ep=toCanvas(points[i+1].x,points[i+1].y);
        ctx.setLineDash([3,4]); ctx.strokeStyle='rgba(124,58,237,0.5)'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(sp.cx,sp.cy); ctx.lineTo(cc1.cx,cc1.cy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ep.cx,ep.cy); ctx.lineTo(cc2.cx,cc2.cy); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle='rgba(124,58,237,0.8)';
        ctx.beginPath(); ctx.arc(cc1.cx,cc1.cy,4,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cc2.cx,cc2.cy,4,0,Math.PI*2); ctx.fill();
      }
    }
  }

  // Anchor ring on first point
  if (points.length > 0) {
    const {ox,oy} = getOriginOffset();
    const a = toCanvas(points[0].x, points[0].y);
    ctx.strokeStyle='rgba(0,212,255,0.3)'; ctx.lineWidth=1; ctx.setLineDash([2,3]);
    ctx.beginPath(); ctx.arc(a.cx,a.cy,14,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='rgba(0,212,255,0.6)'; ctx.font='9px JetBrains Mono'; ctx.textAlign='left';
    ctx.fillText(`(${ox}, ${oy})`, a.cx+14, a.cy-8);
  }

  // Waypoints
  const ptR = Math.max(5, Math.min(9, zoom*0.55));
  points.forEach((pt, i) => {
    const {cx,cy} = toCanvas(pt.x, pt.y);
    const sel = i === selectedIdx, first = i===0, last = i===points.length-1;
    const tang = headingToTangent(pt.heading);
    const al = ptR*2.2;
    const ax = cx + tang.dx*al, ay = cy - tang.dy*al;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(ax,ay);
    ctx.strokeStyle = sel?'#f59e0b':'rgba(0,212,255,0.6)'; ctx.lineWidth=2; ctx.stroke();
    const ang = Math.atan2(-(ay-cy), ax-cx);
    ctx.beginPath();
    ctx.moveTo(ax,ay);
    ctx.lineTo(ax-6*Math.cos(ang-0.4), ay-6*Math.sin(ang-0.4));
    ctx.lineTo(ax-6*Math.cos(ang+0.4), ay-6*Math.sin(ang+0.4));
    ctx.closePath();
    ctx.fillStyle = sel?'#f59e0b':'rgba(0,212,255,0.6)'; ctx.fill();

    ctx.beginPath(); ctx.arc(cx,cy,ptR,0,Math.PI*2);
    ctx.fillStyle = first?'#10b981': last?'#ef4444': sel?'#f59e0b':'#00d4ff';
    ctx.fill();
    ctx.strokeStyle = sel?'white':'rgba(0,0,0,0.5)'; ctx.lineWidth=1.5; ctx.stroke();

    ctx.fillStyle='#0a0a0f';
    ctx.font=`bold ${Math.max(8,ptR*1.1)}px JetBrains Mono`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(i, cx, cy);

    const cc = toCodeCoords(pt);
    ctx.fillStyle='rgba(180,180,200,0.4)'; ctx.font='9px JetBrains Mono';
    ctx.textAlign='left'; ctx.textBaseline='alphabetic';
    ctx.fillText(`(${cc.x}, ${cc.y})`, cx+ptR+4, cy-2);
  });
  ctx.textBaseline='alphabetic'; ctx.textAlign='left';
}

// ---- Hit tests ----
function getHitPoint(cx, cy) {
  const hitR = Math.max(10, zoom*0.7);
  for (let i = 0; i < points.length; i++) {
    const p = toCanvas(points[i].x, points[i].y);
    if (Math.hypot(cx-p.cx, cy-p.cy) < hitR) return i;
  }
  return -1;
}
function getHitHandle(cx, cy) {
  if (!smoothMode || points.length < 2) return null;
  const hitR = 8;
  const ts = parseFloat(document.getElementById('tangentScale').value) || 0.4;
  for (let i = 0; i < points.length - 1; i++) {
    const {c1,c2} = getSegmentHandles(points[i], points[i+1], ts);
    const cc1=toCanvas(c1.x,c1.y), cc2=toCanvas(c2.x,c2.y);
    if (Math.hypot(cx-cc1.cx, cy-cc1.cy) < hitR) return { idx:i,   type:'c1' };
    if (Math.hypot(cx-cc2.cx, cy-cc2.cy) < hitR) return { idx:i+1, type:'c2' };
  }
  return null;
}
function applyHandleDrag(handle, ix, iy) {
  const pt = points[handle.idx];
  if (handle.type === 'c1') {
    const dx=ix-pt.x, dy=iy-pt.y;
    if (Math.hypot(dx,dy) > 0.01) pt.heading = tangentToHeading(dx,dy);
  } else {
    const dx=pt.x-ix, dy=pt.y-iy;
    if (Math.hypot(dx,dy) > 0.01) pt.heading = tangentToHeading(dx,dy);
  }
}

// ---- Mouse events ----
canvas.addEventListener('mousedown', e => {
  const r = canvas.getBoundingClientRect();
  const cx=e.clientX-r.left, cy=e.clientY-r.top;

  if (e.button===1 || (e.button===0 && spaceDown)) {
    isPanning=true; panStartX=e.clientX; panStartY=e.clientY;
    panOriginX=viewOriginX; panOriginY=viewOriginY;
    canvas.classList.add('panning'); return;
  }
  if (e.button!==0) return;

  const hitH = getHitHandle(cx,cy);
  if (hitH) {
    pushHistory(); dragHandle=hitH; selectedIdx=hitH.idx;
    canvas.classList.add('dragging'); updateUI(); render(); return;
  }
  const hit = getHitPoint(cx,cy);
  if (hit >= 0) {
    pushHistory(); dragIdx=hit; selectedIdx=hit;
    canvas.classList.add('dragging');
  } else {
    pushHistory();
    const {ix,iy}=toField(cx,cy);
    const v=parseFloat(document.getElementById('defVel').value)||100;
    let h=0;
    if (points.length>0) { const p=points[points.length-1]; h=tangentToHeading(ix-p.x,iy-p.y); }
    points.push({x:+ix.toFixed(2), y:+iy.toFixed(2), heading:h, velocity:v});
    selectedIdx=points.length-1;
  }
  updateUI(); render();
});

canvas.addEventListener('mousemove', e => {
  const r=canvas.getBoundingClientRect();
  const cx=e.clientX-r.left, cy=e.clientY-r.top;
  const {ix,iy}=toField(cx,cy);
  if (points.length>0) {
    const {ox,oy}=getOriginOffset(), a=points[0];
    document.getElementById('coordsBadge').textContent=`x: ${+(ix-a.x+ox).toFixed(1)}"  y: ${+(iy-a.y+oy).toFixed(1)}"`;
  } else {
    document.getElementById('coordsBadge').textContent=`x: ${ix.toFixed(1)}"  y: ${iy.toFixed(1)}"`;
  }
  if (isPanning) {
    viewOriginX=panOriginX+(e.clientX-panStartX);
    viewOriginY=panOriginY+(e.clientY-panStartY);
    render(); return;
  }
  if (dragHandle) { applyHandleDrag(dragHandle, ix, iy); updateUI(); render(); return; }
  if (dragIdx>=0) {
    points[dragIdx].x=+ix.toFixed(2); points[dragIdx].y=+iy.toFixed(2);
    updateUI(); render(); return;
  }
  const hitH=getHitHandle(cx,cy), hit=getHitPoint(cx,cy);
  canvas.className = spaceDown?'panning': hitH||hit>=0?'hover-pt':'';
});

canvas.addEventListener('mouseup', () => {
  if (isPanning) { isPanning=false; canvas.classList.remove('panning'); return; }
  dragIdx=-1; dragHandle=null; canvas.classList.remove('dragging');
});

canvas.addEventListener('dblclick', e => {
  const r=canvas.getBoundingClientRect();
  const hit=getHitPoint(e.clientX-r.left, e.clientY-r.top);
  if (hit>=0) {
    pushHistory(); points.splice(hit,1);
    if (selectedIdx>=points.length) selectedIdx=points.length-1;
    updateUI(); render();
  }
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const r=canvas.getBoundingClientRect();
  const cx=e.clientX-r.left, cy=e.clientY-r.top;
  const {ix,iy}=toField(cx,cy);
  zoom=Math.max(0.5,Math.min(40,zoom*(e.deltaY<0?1.15:1/1.15)));
  viewOriginX=cx-ix*zoom; viewOriginY=cy+iy*zoom;
  render();
},{passive:false});

window.addEventListener('keydown', e => {
  if (e.code==='Space'&&!e.target.matches('input')) { e.preventDefault(); spaceDown=true; canvas.classList.add('panning'); }
});
window.addEventListener('keyup', e => {
  if (e.code==='Space') { spaceDown=false; if (!isPanning) canvas.classList.remove('panning'); }
});

document.getElementById('btnZoomIn').addEventListener('click',()=>{ zoom=Math.min(40,zoom*1.3); render(); });
document.getElementById('btnZoomOut').addEventListener('click',()=>{ zoom=Math.max(0.5,zoom/1.3); render(); });
document.getElementById('btnZoomReset').addEventListener('click',()=>{ zoom=4; viewOriginX=canvas.width/2; viewOriginY=canvas.height/2; render(); });

// ---- Edit panel ----
function setupEditListeners() {
  ['eX','eY','eH','eV'].forEach(id => {
    document.getElementById(id).addEventListener('input', () => {
      if (selectedIdx<0||!points[selectedIdx]) return;
      const {ox,oy}=getOriginOffset(), a=points[0];
      const cx2=parseFloat(document.getElementById('eX').value);
      const cy2=parseFloat(document.getElementById('eY').value);
      const h=parseFloat(document.getElementById('eH').value);
      const v=parseFloat(document.getElementById('eV').value);
      if (!isNaN(cx2)) points[selectedIdx].x=cx2-ox+a.x;
      if (!isNaN(cy2)) points[selectedIdx].y=cy2-oy+a.y;
      if (!isNaN(h))   points[selectedIdx].heading=((h%360)+360)%360;
      if (!isNaN(v))   points[selectedIdx].velocity=Math.min(127,Math.max(0,v));
      updateUI(); render();
    });
  });
}

// ---- UI ----
function updateUI() {
  const list=document.getElementById('pointList');
  list.innerHTML='';
  points.forEach((pt,i)=>{
    const cc=toCodeCoords(pt);
    const d=document.createElement('div');
    d.className='pt-item'+(i===selectedIdx?' selected':'');
    d.innerHTML=`<div class="pt-label">${i===0?'⬤ START':i===points.length-1?'⬤ END':'PT '+i}</div>
<div class="pt-vals">x: ${cc.x}"  y: ${cc.y}"  hdg: ${pt.heading.toFixed(0)}°  vel: ${pt.velocity}</div>
<button class="pt-del" data-i="${i}">✕</button>`;
    d.addEventListener('click',ev=>{
      if (ev.target.classList.contains('pt-del')) {
        pushHistory(); points.splice(parseInt(ev.target.dataset.i),1);
        if (selectedIdx>=points.length) selectedIdx=points.length-1;
      } else { selectedIdx=i; }
      updateUI(); render();
    });
    list.appendChild(d);
  });

  const ep=document.getElementById('editPanel');
  if (selectedIdx>=0&&points[selectedIdx]) {
    ep.style.display='block';
    const cc=toCodeCoords(points[selectedIdx]);
    document.getElementById('eX').value=cc.x;
    document.getElementById('eY').value=cc.y;
    document.getElementById('eH').value=points[selectedIdx].heading.toFixed(0);
    document.getElementById('eV').value=points[selectedIdx].velocity;
  } else { ep.style.display='none'; }

  updateCode();
  document.getElementById('modeHint').textContent=
    points.length===0?'Click on canvas to place first waypoint':
    points.length===1?'Add more points to build a path':
    `${points.length} waypoints · scroll=zoom · space+drag=pan · dbl-click=delete`;
}

function updateCode() {
  const box=document.getElementById('codeBox');
  if (points.length<2){box.textContent='// Add at least 2 points...';return;}
  const ts=parseFloat(document.getElementById('tangentScale').value)||0.4;
  const sp=parseFloat(document.getElementById('spacingIn').value)||0.5;
  const lines=['chassis.purePursuit(lynx::path({'];
  points.forEach((pt,i)=>{
    const cc=toCodeCoords(pt);
    lines.push(`    {${cc.x}, ${cc.y}, ${pt.heading.toFixed(1)}, ${pt.velocity}}${i<points.length-1?',':''}`);
  });
  lines.push(`}, ${ts}, ${sp}), 5000, params);`);
  box.textContent=lines.join('\n');
}

// ---- Buttons ----
document.getElementById('btnClear').addEventListener('click',()=>{pushHistory();points=[];selectedIdx=-1;updateUI();render();});
document.getElementById('btnUndo').addEventListener('click',()=>{if(history.length>0){points=history.pop();selectedIdx=-1;updateUI();render();}});
document.getElementById('btnReverse').addEventListener('click',()=>{
  if(points.length<2)return;
  pushHistory();
  points.reverse();
  points=points.map(p=>({...p,heading:((p.heading+180)%360)}));
  selectedIdx=-1; updateUI(); render();
});
document.getElementById('btnSmooth').addEventListener('click',()=>{
  smoothMode=!smoothMode;
  document.getElementById('btnSmooth').classList.toggle('active',smoothMode);
  render();
});

// Copy button — works on file:// and HTTP via textarea fallback
document.getElementById('btnCopy').addEventListener('click',()=>{
  const text=document.getElementById('codeBox').textContent;
  const btn=document.getElementById('btnCopy');
  function done(ok){ btn.textContent=ok?'Copied!':'Select + Ctrl+C'; setTimeout(()=>{btn.textContent='Copy to Clipboard';},1500); }
  if (navigator.clipboard&&navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text).then(()=>done(true)).catch(()=>fallback());
  } else { fallback(); }
  function fallback(){
    const ta=document.createElement('textarea');
    ta.value=text; ta.style.cssText='position:fixed;top:-9999px;left:-9999px;opacity:0';
    document.body.appendChild(ta); ta.focus(); ta.select();
    try{document.execCommand('copy');done(true);}catch{done(false);}
    document.body.removeChild(ta);
  }
});

['tangentScale','spacingIn','defVel'].forEach(id=>{
  document.getElementById(id).addEventListener('input',()=>{updateUI();render();});
});
['originX','originY'].forEach(id=>{
  document.getElementById(id).addEventListener('input',()=>{updateUI();render();});
});

function pushHistory(){
  history.push(JSON.parse(JSON.stringify(points)));
  if(history.length>30)history.shift();
}

setupEditListeners();
window.addEventListener('resize',resizeCanvas);
resizeCanvas();
updateUI();
</script>
</body>
</html>